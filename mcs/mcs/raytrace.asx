package {

	import Math;

	class Vector {

		public var x: Number;
		public var y: Number;
		public var z: Number;

		public function Vector x: Number, y: Number, z: Number) { 
			this.x = x;
			this.y = y;
			this.z = z;
		}
		
		public static function times(k: Number, v: Vector) {
			return new Vector(k * v.x, k * v.y, k * v.z);
		}
		
		public static function minus(v1: Vector, v2: Vector) {
			return new Vector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
		}
		
		public static function plus(v1: Vector, v2: Vector) {
			return new Vector(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
		}
		
		public static dot(v1: Vector, v2: Vector) {
			return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
		}
		
		public static mag(v: Vector) {
			return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
		}
		
		public static norm(v: Vector) {
			var mag = Vector.mag(v);
			var div = (mag === 0) ? Infinity : 1.0 / mag;
			return Vector.times(div, v);
		}
		
		public static cross(v1: Vector, v2: Vector) {
			return new Vector(v1.y * v2.z - v1.z * v2.y,
			                  v1.z * v2.x - v1.x * v2.z,
			                  v1.x * v2.y - v1.y * v2.x);
		}
		
	}

	public class Color {

		public var r: Number;
		public var g: Number;
		public var b: Number;
		
		public function Color(r: Number, g: Number, b: Number) {
			this.r = r;
			this.g = g;
			this.b = b;
		}

		public static scale(k: Number, v: Color) {
			return new Color(k * v.r, k * v.g, k * v.b);
		}
		
		public static plus(v1: Color, v2: Color) {
			return new Color(v1.r + v2.r, v1.g + v2.g, v1.b + v2.b);
		}
		
		public static times(v1: Color, v2: Color) {
			return new Color(v1.r * v2.r, v1.g * v2.g, v1.b * v2.b);
		}
		
		public static const white: Color = new Color(1.0, 1.0, 1.0);
		public static const grey: Color = new Color(0.5, 0.5, 0.5);
		public static const black: Color = new Color(0.0, 0.0, 0.0);
		public static const background: Color = Color.black;
		public static const defaultColor: Color = Color.black;
		
		public static toDrawingColor(c: Color) {
			var legalize = d => d > 1 ? 1 : d;
			return {
					r: Math.floor(legalize(c.r) * 255),
					g: Math.floor(legalize(c.g) * 255),
					b: Math.floor(legalize(c.b) * 255)
				};
		}
		
	}

	public class Camera {
		
		public var forward: Vector;
		public var right: Vector;
		public var up: Vector;
		public var pos: Vector;

		public function Camera(pos: Vector, lookAt: Vector) {
			var down = new Vector(0.0, -1.0, 0.0);
			this.pos = pos;
			this.forward = Vector.norm(Vector.minus(lookAt, this.pos));
			this.right = Vector.times(1.5, Vector.norm(Vector.cross(this.forward, down)));
			this.up = Vector.times(1.5, Vector.norm(Vector.cross(this.forward, this.right)));
		}
		
	}

	public interface Ray {
		property start: Vector { get; set; }
		property dir: Vector { get; set; }
	}

	public interface Intersection {
		property thing: Thing { get; set; }
		property ray: Ray { get; set; }
		property dist: Number { get; set; }
	}

	public interface Surface {
		diffuse: (pos: Vector) => Color;
		specular: (pos: Vector) => Color;
		reflect: (pos: Vector) => Number;
		roughness: Number;
	}

	public interface Thing {
		intersect: (ray: Ray) => Intersection;
		normal: (pos: Vector) => Vector;
		surface: Surface;
	}

	public interface Light {
		pos: Vector;
		color: Color;
	}

	public interface Scene {
		property things: Vector.<Thing> { get; }
		property lights: Light[] { get; }
		property camera: Camera { get; }
	}

	public class Sphere implements Thing {

		public var center: Vector;
		public var radius2: Number;
		public var surface: Surface;
		
		constructor(center: Vector, radius: Number, public surface: Surface) {
			this.center = center;
			this.radius2 = radius * radius;
		}
		
		public function normal(pos: Vector): Vector {
			return Vector.norm(Vector.minus(pos, this.center));
		}

		public function intersect(ray: Ray): Object {
			var eo:Vector = Vector.minus(this.center, ray.start);
			var v:Vector = Vector.dot(eo, ray.dir);
			var dist:Number = 0;
			if (v >= 0) {
				var disc = this.radius2 - (Vector.dot(eo, eo) - v * v);
				if (disc >= 0) {
					dist = v - Math.sqrt(disc);
				}
			}
			if (dist === 0) {
				return null;
			} else {
				return { thing: this, ray: ray, dist: dist };
			}
		}
		
	}

	public class Plane implements Thing {
		
		normal: (pos: Vector) => Vector;
		intersect: (ray: Ray) => Intersection;
		
		public function Plane(norm: Vector, offset: Number, public surface: Surface) {
			this.normal = function(pos: Vector) { return norm; }
			this.intersect = function(ray: Ray): Intersection {
				var denom:Vector = Vector.dot(norm, ray.dir);
				if (denom > 0) {
					return null;
				} else {
					var dist:Vector = (Vector.dot(norm, ray.start) + offset) / (-denom);
					return { thing: this, ray: ray, dist: dist };
				}
			}
		}
		
	}

	public static class Surfaces {

		public const shiny: Surface = {
			diffuse: function(pos) { return Color.white; },
			specular: function(pos) { return Color.grey; },
			reflect: function(pos) { return 0.7; },
			roughness: 250
		};
		
		public const checkerboard: Surface = {
			diffuse: function(pos) {
					if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 !== 0) {
						return Color.white;
					} else {
						return Color.black;
					}
				},
			specular: function(pos) { return Color.white; },
			reflect: function(pos) {
					if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 !== 0) {
						return 0.1;
					} else {
						return 0.7;
					}
				},
			roughness: 150
		};
		
	}

	public class RayTracer {
		
		private const maxDepth: Number = 5;
		
		private function intersections(ray: Ray, scene: Scene):Intersection {
			var closest: Number = +Infinity;
			var closestInter: Intersection = undefined;
			for (var i in scene.things) {
				var inter = scene.things[i].intersect(ray);
				if (inter != null && inter.dist < closest) {
					closestInter = inter;
					closest = inter.dist;
				}
			}
			return closestInter;
		}
		
		private function testRay(ray: Ray, scene: Scene):* {
			var isect:Intersection = this.intersections(ray, scene);
			if (isect != null) {
				return isect.dist;
			} else {
				return undefined;
			}
		}
		
		private function traceRay(ray: Ray, scene: Scene, depth: Number):Color {
			var isect:Vector = this.intersections(ray, scene);
			if (isect === undefined) {
				return Color.background;
			} else {
				return this.shade(isect, scene, depth);
			}
		}
		
		private function shade(isect: Intersection, scene: Scene, depth: Number):Color {
			var d:Vector = isect.ray.dir;
			var pos:Vector = Vector.plus(Vector.times(isect.dist, d), isect.ray.start);
			var normal:Vector = isect.thing.normal(pos);
			var reflectDir:Vector = Vector.minus(d, Vector.times(2, Vector.times(Vector.dot(normal, d), normal)));
			var naturalColor:Color = Color.plus(Color.background,
			                              this.getNaturalColor(isect.thing, pos, normal, reflectDir, scene));
			var reflectedColor:Color = (depth >= this.maxDepth) ? Color.grey : this.getReflectionColor(isect.thing, pos, normal, reflectDir, scene, depth);
			return Color.plus(naturalColor, reflectedColor);
		}
		
		private function getReflectionColor(thing: Thing, pos: Vector, normal: Vector, rd: Vector, scene: Scene, depth: Number):Color {
			return Color.scale(thing.surface.reflect(pos), this.traceRay({ start: pos, dir: rd }, scene, depth + 1));
		}
		
		private function getNaturalColor(thing: Thing, pos: Vector, norm: Vector, rd: Vector, scene: Scene) {
			var addLight = function (col, light):Color {
				var ldis = Vector.minus(light.pos, pos);
				var livec = Vector.norm(ldis);
				var neatIsect = this.testRay({ start: pos, dir: livec }, scene);
				var isInShadow = (neatIsect === undefined) ? false : (neatIsect <= Vector.mag(ldis));
				if (isInShadow) {
					return col;
				} else {
					var illum = Vector.dot(livec, norm);
					var lcolor = (illum > 0) ? Color.scale(illum, light.color)
						: Color.defaultColor;
					var specular = Vector.dot(livec, Vector.norm(rd));
					var scolor = (specular > 0) ? Color.scale(Math.pow(specular, thing.surface.roughness), light.color)
						: Color.defaultColor;
					return Color.plus(col, Color.plus(Color.times(thing.surface.diffuse(pos), lcolor),
					                                  Color.times(thing.surface.specular(pos), scolor)));
				}
			}
			return scene.lights.reduce(addLight, Color.defaultColor);
		}
		
		public function render(scene: Scene, ctx: Object, screenWidth: Number, screenHeight: Number):void {
			var getPoint = function (x, y, camera):Vector => {
				var recenterX = x => (x - (screenWidth / 2.0)) / 2.0 / screenWidth;
				var recenterY = y => -(y - (screenHeight / 2.0)) / 2.0 / screenHeight;
				return Vector.norm(Vector.plus(camera.forward, Vector.plus(Vector.times(recenterX(x), camera.right), Vector.times(recenterY(y), camera.up))));
			}
			for (var y = 0; y < screenHeight; y++) {
				for (var x = 0; x < screenWidth; x++) {
					var color = this.traceRay({ start: scene.camera.pos, dir: getPoint(x, y, scene.camera) }, scene, 0);
					var c = Color.toDrawingColor(color);
					ctx.fillStyle = "rgb(" + String(c.r) + ", " + String(c.g) + ", " + String(c.b) + ")";
					ctx.fillRect(x, y, x + 1, y + 1);
				}
			}
		}
		
	}

	public class Program {

		private static function defaultScene(): Scene {
			return {
			things: [new Plane(new Vector(0.0, 1.0, 0.0), 0.0, Surfaces.checkerboard),
				         new Sphere(new Vector(0.0, 1.0, -0.25), 1.0, Surfaces.shiny),
				         new Sphere(new Vector(-1.0, 0.5, 1.5), 0.5, Surfaces.shiny)],
			lights: [{ pos: new Vector(-2.0, 2.5, 0.0), color: new Color(0.49, 0.07, 0.07) },
				         { pos: new Vector(1.5, 2.5, 1.5), color: new Color(0.07, 0.07, 0.49) },
				         { pos: new Vector(1.5, 2.5, -1.5), color: new Color(0.07, 0.49, 0.071) },
				         { pos: new Vector(0.0, 3.5, 0.0), color: new Color(0.21, 0.21, 0.35) }],
			camera: new Camera(new Vector(3.0, 2.0, 4.0), new Vector(-1.0, 0.5, 0.0))
			};
		}

		public static function main(document:Object):void {
			var canv:Object = document.createElement("canvas");
			canv.width = 256;
			canv.height = 256;
			document.body.appendChild(canv);
			var ctx:Object = canv.getContext("2d");
			var rayTracer:Raytracer = new RayTracer();
			rayTracer.render(defaultScene(), ctx, 256, 256);
		}

	}
}
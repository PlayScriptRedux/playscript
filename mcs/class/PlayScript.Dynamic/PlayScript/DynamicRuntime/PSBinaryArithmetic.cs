		
//
// PSBinaryArithmetic.cs
//
// Copyright 2013 Zynga Inc.
//	
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//		
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.

#if !DYNAMIC_SUPPORT

using System;

//
// WARNING: This code is autogenerated. Edit PSBinaryArithmetic.tt to make changes.
//
namespace PlayScript.DynamicRuntime
{
	//
	// Arithmetic operations are using the following rules:
	//	A. If the object is of type of the other operand, cast the operand to the common type, and do the operation directly.
	//	B. If the object is of different type, we whole operation is done in double precision.
	// This keeps fast performance if the user code keeps all types the same, and allows for other cases to keep maximum precision.
	// There is a bit of performance loss in some cases (like when mixing int with uint), but it should not be common with AS.
	//
	// We also have to test for null and undefined (before calling Convert.ToXYZ().
	// Here are the checks these operators have to do:
	//	1. If of expected, type direct cast and apply the operation.
	//	2. If null, assume the value is 0 and apply the operation.
	//	3. If undefined, result of the operation is always NaN.
	//	4. Otherwise convert to Double both operands and apply the operation.
	//
	public static class PSBinaryArithmetic
	{
		public static string ADD = "+";
		public static string SUB = "-";
		public static string MUL = "*";
		public static string DIV = "/";
		public static string MOD = "%";

		public static object AdditionObjInt (object a, int b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is int)
				return (int)a + b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) + (double)b;

			if (a is string)
				return (string)a + b.ToString ();

			ThrowOnInvalidOp (ADD, a, b);
			return null;
		}

		public static object AdditionIntObj (int a, object b)
		{
			return AdditionObjInt (b, a);
		}

		public static object SubtractionObjInt (object a, int b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is int)
				return (int)a - b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return -b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) - (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value - (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}
			
			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object SubtractionIntObj (int a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is int)
				return a - (int)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a; // null converts to 0

			if (IsNumeric (b))
				return (double)a - Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a - value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object MultiplyObjInt (object a, int b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is int)
				return (int)a * b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) * (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value * (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MUL, a, b);
			return null;
		}

		public static object MultiplyIntObj (int a, object b)
		{
			return MultiplyObjInt (b, a);
		}

		public static object DivisionObjInt (object a, int b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is int)
				return (int)a / b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) / (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value / (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object DivisionIntObj (int a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is int)
				return a / (int)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a / 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a / Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a / value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object ModulusObjInt (object a, int b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is int)
				return (int)a % b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) % (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value % (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object ModulusIntObj (int a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is int)
				return a % (int)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a % 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a % Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a % value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object AdditionObjUInt (object a, uint b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is uint)
				return (uint)a + b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) + (double)b;

			if (a is string)
				return (string)a + b.ToString ();

			ThrowOnInvalidOp (ADD, a, b);
			return null;
		}

		public static object AdditionUIntObj (uint a, object b)
		{
			return AdditionObjUInt (b, a);
		}

		public static object SubtractionObjUInt (object a, uint b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is uint)
				return (uint)a - b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return -b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) - (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value - (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}
			
			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object SubtractionUIntObj (uint a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is uint)
				return a - (uint)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a; // null converts to 0

			if (IsNumeric (b))
				return (double)a - Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a - value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object MultiplyObjUInt (object a, uint b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is uint)
				return (uint)a * b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) * (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value * (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MUL, a, b);
			return null;
		}

		public static object MultiplyUIntObj (uint a, object b)
		{
			return MultiplyObjUInt (b, a);
		}

		public static object DivisionObjUInt (object a, uint b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is uint)
				return (uint)a / b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) / (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value / (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object DivisionUIntObj (uint a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is uint)
				return a / (uint)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a / 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a / Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a / value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object ModulusObjUInt (object a, uint b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is uint)
				return (uint)a % b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) % (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value % (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object ModulusUIntObj (uint a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is uint)
				return a % (uint)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a % 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a % Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a % value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object AdditionObjDouble (object a, double b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is double)
				return (double)a + b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) + (double)b;

			if (a is string)
				return (string)a + b.ToString ();

			ThrowOnInvalidOp (ADD, a, b);
			return null;
		}

		public static object AdditionDoubleObj (double a, object b)
		{
			return AdditionObjDouble (b, a);
		}

		public static object SubtractionObjDouble (object a, double b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is double)
				return (double)a - b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return -b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) - (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value - (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}
			
			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object SubtractionDoubleObj (double a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is double)
				return a - (double)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a; // null converts to 0

			if (IsNumeric (b))
				return (double)a - Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a - value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object MultiplyObjDouble (object a, double b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is double)
				return (double)a * b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) * (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value * (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MUL, a, b);
			return null;
		}

		public static object MultiplyDoubleObj (double a, object b)
		{
			return MultiplyObjDouble (b, a);
		}

		public static object DivisionObjDouble (object a, double b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is double)
				return (double)a / b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) / (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value / (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object DivisionDoubleObj (double a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is double)
				return a / (double)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a / 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a / Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a / value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object ModulusObjDouble (object a, double b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is double)
				return (double)a % b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) % (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value % (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object ModulusDoubleObj (double a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is double)
				return a % (double)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a % 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a % Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a % value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		private static void ThrowOnInvalidOp (string op, object a, object b)
		{
			throw new Exception (String.Format ("Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
			                                    op, a.GetType ().Name, b.GetType ().Name));
		}

		private static bool IsNumeric (object a)
		{
			if (a == null)
				return false;

			switch (Type.GetTypeCode (a.GetType ())) {
			case TypeCode.Byte:
			case TypeCode.SByte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
			case TypeCode.Decimal:
			case TypeCode.Double:
			case TypeCode.Single:
				return true;
			default:
				return false;
			}
		}
	}
}

#endif

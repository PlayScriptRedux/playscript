<#@ template language="C#v3.5" #>		
//
// PSBinaryArithmetic.cs
//
// Copyright 2013 Zynga Inc.
//	
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//		
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.

#if !DYNAMIC_SUPPORT

using System;

//
// WARNING: This code is autogenerated. Edit PSBinaryArithmetic.tt to make changes.
//
namespace PlayScript.DynamicRuntime
{
	//
	// Arithmetic operations are using the following rules:
	//	A. If the object is of type of the other operand, cast the operand to the common type, and do the operation directly.
	//	B. If the object is of different type, we whole operation is done in double precision.
	// This keeps fast performance if the user code keeps all types the same, and allows for other cases to keep maximum precision.
	// There is a bit of performance loss in some cases (like when mixing int with uint), but it should not be common with AS.
	//
	// We also have to test for null and undefined (before calling Convert.ToXYZ().
	// Here are the checks these operators have to do:
	//	1. If of expected, type direct cast and apply the operation.
	//	2. If null, assume the value is 0 and apply the operation.
	//	3. If undefined, result of the operation is always NaN.
	//	4. Otherwise convert to Double both operands and apply the operation.
	//
	public static class PSBinaryArithmetic
	{
		public static string ADD = "+";
		public static string SUB = "-";
		public static string MUL = "*";
		public static string DIV = "/";
		public static string MOD = "%";

<#
string[] types = new string[] { "Int", "UInt", "Double" };
foreach (string type in types) {
	string T = type.ToLower();
#>
		public static object AdditionObj<#=type#> (object a, <#=T#> b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is <#=T#>)
				return (<#=T#>)a + b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) + (double)b;

			if (a is string)
				return (string)a + b.ToString ();

			ThrowOnInvalidOp (ADD, a, b);
			return null;
		}

		public static object Addition<#=type#>Obj (<#=T#> a, object b)
		{
			return AdditionObj<#=type#> (b, a);
		}

		public static object SubtractionObj<#=type#> (object a, <#=T#> b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is <#=T#>)
				return (<#=T#>)a - b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return -b; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) - (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value - (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}
			
			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object Subtraction<#=type#>Obj (<#=T#> a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is <#=T#>)
				return a - (<#=T#>)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a; // null converts to 0

			if (IsNumeric (b))
				return (double)a - Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a - value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (SUB, a, b);
			return null;
		}

		public static object MultiplyObj<#=type#> (object a, <#=T#> b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is <#=T#>)
				return (<#=T#>)a * b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) * (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value * (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MUL, a, b);
			return null;
		}

		public static object Multiply<#=type#>Obj (<#=T#> a, object b)
		{
			return MultiplyObj<#=type#> (b, a);
		}

		public static object DivisionObj<#=type#> (object a, <#=T#> b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is <#=T#>)
				return (<#=T#>)a / b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) / (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value / (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object Division<#=type#>Obj (<#=T#> a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is <#=T#>)
				return a / (<#=T#>)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a / 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a / Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a / value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (DIV, a, b);
			return null;
		}

		public static object ModulusObj<#=type#> (object a, <#=T#> b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (a is <#=T#>)
				return (<#=T#>)a % b;

			if (a == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (a == null)
				return 0; // null converts to 0

			if (IsNumeric (a))
				return Convert.ToDouble (a) % (double)b;

			if (a is string) {
				double value;
				if (Double.TryParse ((string)a, out value))
					return value % (double)b;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

		public static object Modulus<#=type#>Obj (<#=T#> a, object b)
		{
			Stats.Increment(StatsCounter.BinaryOperationBinderInvoked);

			if (b is <#=T#>)
				return a % (<#=T#>)b;

			if (b == PlayScript.Undefined._undefined)
				return Double.NaN; // any math with undefined results in NaN

			if (b == null)
				return a % 0; // null converts to 0

			if (IsNumeric (b))
				return (double)a % Convert.ToDouble (b);

			if (b is string) {
				double value;
				if (Double.TryParse ((string)b, out value))
					return (double)a % value;
				return Double.NaN; // non-numeric strings convert to NaN
			}

			ThrowOnInvalidOp (MOD, a, b);
			return null;
		}

<#
}
#>
		private static void ThrowOnInvalidOp (string op, object a, object b)
		{
			throw new Exception (String.Format ("Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
			                                    op, a.GetType ().Name, b.GetType ().Name));
		}

		private static bool IsNumeric (object a)
		{
			if (a == null)
				return false;

			switch (Type.GetTypeCode (a.GetType ())) {
			case TypeCode.Byte:
			case TypeCode.SByte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
			case TypeCode.Decimal:
			case TypeCode.Double:
			case TypeCode.Single:
				return true;
			default:
				return false;
			}
		}
	}
}

#endif

<Type Name="RSACryptoServiceProvider" FullName="System.Security.Cryptography.RSACryptoServiceProvider">
  <TypeSignature Maintainer="auto" Language="C#" Value="public sealed class RSACryptoServiceProvider : System.Security.Cryptography.RSA, System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RSACryptoServiceProvider extends System.Security.Cryptography.RSA implements class System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.Security.Cryptography.RSA</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Cryptography.ICspAsymmetricAlgorithm</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Managed implementation of the RSA asymmetric algorithm.</summary>
    <remarks>
      <para>In Mono this class is completely implemented in managed code.</para>
      <para>A major design difference between Mono and Microsoft implementation is the key generation. Microsoft always generate a new key pair in the constructor (unless a <see cref="T:System.Security.Cryptography.CspParameters" /> object is used with an non-empty container). This can degrade performance (e.g. server) when key pair are imported (e.g. XML) after the object is created. Mono implementation doesn't generate a new key pair until it is required (e.g. exporting, signing, encrypting ...). This shouldn't affect functionality but you may experience slowdown (during key pair generation) at a different time than MS implementation.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>Create a new RSACryptoServiceProvider instance with the specified key pair length. </summary>
        <remarks>Default key size is 1024 bits.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">Length of the public key modulus. This can be between 384 and 16384 bits in multiple of 8 bits increments.</param>
        <summary>Create a new DSACryptoServiceProvider instance with the specified key pair length.</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">To be added: an object of type 'CspParameters'</param>
        <summary>Create a new RSACryptoServiceProvider instance with the default key pair length. The generated key pair will be persisted in the key store specified by the CspParameters.</summary>
        <remarks>Default key size is 1024 bits.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize, System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize, class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">Length of the public key modulus. This can be between 384 and 16384 bits in multiple of 8 bits increments.</param>
        <param name="parameters">To be added: an object of type 'CspParameters'</param>
        <summary>Create a new RSACryptoServiceProvider instance with the specified key pair length. The generated key pair will be persisted in the key store specified by the CspParameters.</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="CspKeyContainerInfo">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CspKeyContainerInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public byte[] Decrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Decrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">The encrypted data.</param>
        <param name="fOAEP">True to use the OAEP padding, false to use PKCS#1 padding.</param>
        <summary>Decrypt the provided data using the private key and the specified padding mechanism.</summary>
        <returns>An array of bytes containing the decrypted data.</returns>
        <remarks>
          <para>RSA isn't normally used to do bulk encryption. The two main reasons are length restriction (public key size and padding limit the maximum length of data that can be encrypted in a single operation) and performance (as RSA is very slow compared to most symmetric ciphers).</para>
          <para>The following example shows how to combine the use of RSA and a symmetric cipher, Rjindael, to "quickly" decrypt data of an unlimited length (provided is was encrypted with the reversed algorithm).</para>
          <example>
            <code lang="C#">
static byte[] Decrypt (RSA rsa, byte[] input) 
{
     // by default this will create a 128 bits AES (Rijndael) object
     SymmetricAlgorithm sa = SymmetricAlgorithm.Create ();

     byte[] keyex = new byte [rsa.KeySize &gt;&gt; 3];
     Buffer.BlockCopy (input, 0, keyex, 0, keyex.Length);

     RSAPKCS1KeyExchangeDeformatter def = new RSAPKCS1KeyExchangeDeformatter (rsa);
     byte[] key = def.DecryptKeyExchange (keyex);

     byte[] iv = new byte [sa.IV.Length];
     Buffer.BlockCopy (input, keyex.Length, iv, 0, iv.Length);

     ICryptoTransform ct = sa.CreateDecryptor (key, iv);
     byte[] decrypt = ct.TransformFinalBlock (input, keyex.Length + iv.Length, input.Length - (keyex.Length + iv.Length));
     return decrypt;
}
  </code>
          </example>
          <para>Interoperability warning: Microsoft CryptoAPI only supports OAEP since Windows XP.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecryptValue">
      <MemberSignature Language="C#" Value="public override byte[] DecryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DecryptValue(unsigned int8[] rgb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">The encrypted data.</param>
        <summary>Raw (unpadded) decryption using the RSA private key.</summary>
        <returns>An array of bytes containing the decrypted data. </returns>
        <remarks>
          <para>Note: This method is implemented in Mono but isn't supported in the Microsoft .NET framework. There are good reason for this:</para>
          <list type="bullet">
            <item>
              <term>Mono requires the method to implement the RSA Formatter and Deformatter classes.</term>
            </item>
            <item>
              <term>Microsoft's CryptoAPI doesn't support direct RSA encryption/decryption.</term>
            </item>
            <item>
              <term>You shouldn't be using them anyway!!! as this isn't the way to encrypt using RSA. You need to apply padding before encrypting (and remove it when decrypting). Not doing so is both dangerous (non secure) and very slow.</term>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added: an object of type 'bool'</param>
        <summary>To be added</summary>
        <remarks>The private key is zeroized during Dispose.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">The data to be encrypted.</param>
        <param name="fOAEP">True to use the OAEP padding, false to use PKCS#1 padding.</param>
        <summary>Encrypt the provided data using the public key and the specified padding mechanism.</summary>
        <returns>An array of bytes containing the encrypted data.</returns>
        <remarks>
          <para>RSA isn't normally used to do bulk encryption. The two main reasons are length restriction (public key size and padding limit the maximum length of data that can be encrypted in a single operation) and performance (as RSA is very slow compared to most symmetric ciphers).</para>
          <para>The following example shows how to combine the use of RSA and a symmetric cipher, Rjindael, to "quickly" encrypt data of an unlimited length.</para>
          <example>
            <code lang="C#">
static byte[] Encrypt (RSA rsa, byte[] input) 
{
     // by default this will create a 128 bits AES (Rijndael) object
     SymmetricAlgorithm sa = SymmetricAlgorithm.Create ();
     ICryptoTransform ct = sa.CreateEncryptor ();
     byte[] encrypt = ct.TransformFinalBlock (input, 0, input.Length);

     RSAPKCS1KeyExchangeFormatter fmt = new RSAPKCS1KeyExchangeFormatter (rsa);
     byte[] keyex = fmt.CreateKeyExchange (sa.Key);

     // return the key exchange, the IV (public) and encrypted data
     byte[] result = new byte [keyex.Length + sa.IV.Length + encrypt.Length];
     Buffer.BlockCopy (keyex, 0, result, 0, keyex.Length);
     Buffer.BlockCopy (sa.IV, 0, result, keyex.Length, sa.IV.Length);
     Buffer.BlockCopy (encrypt, 0, result, keyex.Length + sa.IV.Length, encrypt.Length);
     return result;
}
  </code>
          </example>
          <para>Interoperability warning: Microsoft CryptoAPI only supports OAEP since Windows XP.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptValue">
      <MemberSignature Language="C#" Value="public override byte[] EncryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] EncryptValue(unsigned int8[] rgb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">The data to be encrypted. </param>
        <summary>Raw (unpadded) encryption using the RSA public key.</summary>
        <returns>An array of bytes containing the encrypted data.</returns>
        <remarks>
          <para>Note: This method is implemented in Mono but isn't supported in the Microsoft .NET framework. There are good reason for this:</para>
          <list type="bullet">
            <item>
              <term>Mono requires the method to implement the RSA Formatter and Deformatter classes.</term>
            </item>
            <item>
              <term>Microsoft's CryptoAPI doesn't support direct RSA encryption/decryption.</term>
            </item>
            <item>
              <term>You shouldn't be using them anyway!!! as this isn't the way to encrypt using RSA. You need to apply padding before encrypting (and remove it when decrypting). Not doing so is both dangerous (non secure) and very slow.</term>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportCspBlob">
      <MemberSignature Language="C#" Value="public byte[] ExportCspBlob (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportCspBlob(bool includePrivateParameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.RSAParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.RSAParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">True to include private parameters; otherwise, false.</param>
        <summary>Export the instance key into a <see cref="T:System.Security.Cryptography.RSAParameters" /> structure.</summary>
        <returns>a RSAParameters structure contaning each parameters of the key.</returns>
        <remarks>You are responsable to zeroize the private key (<see cref="T:System.Security.Cryptography.RSAParameters" /> parameters <see cref="M:System.Security.Cryptography.RSAParameters.D" />, <see cref="M:System.Security.Cryptography.RSAParameters.P" />, <see cref="M:System.Security.Cryptography.RSAParameters.Q" />, <see cref="M:System.Security.Cryptography.RSAParameters.DP" />, <see cref="M:System.Security.Cryptography.RSAParameters.DQ" /> and <see cref="M:System.Security.Cryptography.RSAParameters.InverseQ" />) if you export it from the instance.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportCspBlob">
      <MemberSignature Language="C#" Value="public void ImportCspBlob (byte[] keyBlob);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportCspBlob(unsigned int8[] keyBlob) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="keyBlob">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.RSAParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.RSAParameters parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.RSAParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">A RSAParameters containing the RSA key parameters.</param>
        <summary>Import the key from the <see cref="T:System.Security.Cryptography.DSAParameters" /> structure into the current instance.</summary>
        <remarks>Parameters D, P and Q are required to import an RSA private key. Parameters DP, DQ and InverseQ will be used for the Chinese Remainder Theorem (CRT) optimization if available.
</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return the common, but unique, name when using this algorithm for key exchange.</summary>
        <value>RSA-PKCS1-KeyEx</value>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public override int KeySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return the key length (in bits) of the current key.</summary>
        <value>The size (in bits) of the current key.</value>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistKeyInCsp">
      <MemberSignature Language="C#" Value="public bool PersistKeyInCsp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PersistKeyInCsp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specify if the current key pair is persisted into a Cryptographic Service Provider (CSP)</summary>
        <value>True if the key is persisted, false otherwise.</value>
        <remarks>If specified Mono:: key pair persistance mechanism will kept the keys on disk. A <see cref="T:System.Security.Cryptography.CspParameters" /> must been specified in the constructor to allow key persistance.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicOnly">
      <MemberSignature Language="C#" Value="public bool PublicOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PublicOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return the common, but unique, name when using this algorithm for signature.</summary>
        <value>http://www.w3.org/2000/09/xmldsig#rsa-sha1</value>
        <remarks>This value comes from the W3 "XML-Signature Syntax and Processing" specification available at http://www.w3.org/TR/xmldsig-core/</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, object halg) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The data buffer to be hashed then signed. </param>
        <param name="halg">An object representing the hash algorithm to be used. The object can either be:
<list type="bullet"><item><term>a <see cref="T:System.String" /> representing the hash algorithm name. The hash object will then be created using <see cref="T:System.Security.Cryptography.HashAlgorithm" />.<see cref="M:System.Security.Cryptography.HashAlgorithm.Create" /> (<see cref="T:System.String" />).</term></item><item><term>a <see cref="T:System.Security.Cryptography.HashAlgorithm" /> instance that will be directly used.</term></item><item><term>a <see cref="T:System.Type" /> representing the hash algorithm. The hash object will then be created using <see cref="T:System.Activator" />.<see cref="M:System.Activator.CreateInstance" /> (<see cref="T:System.Type" />).</term></item></list></param>
        <summary>Process the specified hash algorithm on the complete buffer specified then sign it's result.</summary>
        <returns>The signature value of the processed buffer.</returns>
        <remarks>This method can work with ANY configured (OID in machine.config) HashAlgorithm descendant.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (System.IO.Stream inputStream, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(class System.IO.Stream inputStream, object halg) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputStream" Type="System.IO.Stream" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputStream">The data stream to be hashed then signed.</param>
        <param name="halg">An object representing the hash algorithm to be used. The object can either be:
<list type="bullet"><item><term>a <see cref="T:System.String" /> representing the hash algorithm name. The hash object will then be created using <see cref="T:System.Security.Cryptography.HashAlgorithm" />.<see cref="M:System.Security.Cryptography.HashAlgorithm.Create" /> (<see cref="T:System.String" />).</term></item><item><term>a <see cref="T:System.Security.Cryptography.HashAlgorithm" /> instance that will be directly used.</term></item><item><term>a <see cref="T:System.Type" /> representing the hash algorithm. The hash object will then be created using <see cref="T:System.Activator" />.<see cref="M:System.Activator.CreateInstance" /> (<see cref="T:System.Type" />).</term></item></list></param>
        <summary>Process the specified hash algorithm on the stream then sign it's result.</summary>
        <returns>The signature value of the processed buffer.</returns>
        <remarks>This method can work with ANY configured (OID in machine.config) HashAlgorithm descendant.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, int offset, int count, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, int32 offset, int32 count, object halg) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The data buffer to be hashed then signed. </param>
        <param name="offset">To be added: an object of type 'int'</param>
        <param name="count">To be added: an object of type 'int'</param>
        <param name="halg">An object representing the hash algorithm to be used. The object can either be:
<list type="bullet"><item><term>a <see cref="T:System.String" /> representing the hash algorithm name. The hash object will then be created using <see cref="T:System.Security.Cryptography.HashAlgorithm" />.<see cref="M:System.Security.Cryptography.HashAlgorithm.Create" /> (<see cref="T:System.String" />).</term></item><item><term>a <see cref="T:System.Security.Cryptography.HashAlgorithm" /> instance that will be directly used.</term></item><item><term>a <see cref="T:System.Type" /> representing the hash algorithm. The hash object will then be created using <see cref="T:System.Activator" />.<see cref="M:System.Activator.CreateInstance" /> (<see cref="T:System.Type" />).</term></item></list></param>
        <summary>Process the specified hash algorithm on a subset of the buffer specified then sign it's result.</summary>
        <returns>The signature value of the processed buffer.</returns>
        <remarks>This method can work with ANY configured (OID in machine.config) HashAlgorithm descendant.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public byte[] SignHash (byte[] rgbHash, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignHash(unsigned int8[] rgbHash, string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rgbHash">The hash to be signed. </param>
        <param name="str">OID for the hash algorithm using in the signature.</param>
        <summary>Sign the specified hash value.</summary>
        <returns>The signature value of the processed buffer.</returns>
        <remarks>This method is LIMITED to SHA1 and MD5 like the MS framework 1.0 and 1.1 because there's no method to get a hash algorithm from an OID. However there's no such limit when using the RSAPKCS1[De]Formatter class.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMachineKeyStore">
      <MemberSignature Language="C#" Value="public static bool UseMachineKeyStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseMachineKeyStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specified if, by default, the key store for persistance should be the machine store (default is the user store).</summary>
        <value>True if the machine key store is used by default, false otherwise.</value>
        <remarks>Keys kept in the machine store are readable by every user on the system.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] buffer, object halg, byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] buffer, object halg, unsigned int8[] signature) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">The data buffer to be hashed then verified. </param>
        <param name="halg">An object representing the hash algorithm to be used. The object can either be:
<list type="bullet"><item><term>a <see cref="T:System.String" /> representing the hash algorithm name. The hash object will then be created using <see cref="T:System.Security.Cryptography.HashAlgorithm" />.<see cref="M:System.Security.Cryptography.HashAlgorithm.Create" /> (<see cref="T:System.String" />).</term></item><item><term>a <see cref="T:System.Security.Cryptography.HashAlgorithm" /> instance that will be directly used.</term></item><item><term>a <see cref="T:System.Type" /> representing the hash algorithm. The hash object will then be created using <see cref="T:System.Activator" />.<see cref="M:System.Activator.CreateInstance" /> (<see cref="T:System.Type" />).</term></item></list></param>
        <param name="signature">An array of bytes containing the RSA signature of the specified hash.</param>
        <summary>Process the specified hash algorithm on the complete buffer specified then verify it's signature. </summary>
        <returns>True if the signature can be verified, false otherwise.</returns>
        <remarks>This method can work with ANY configured (OID in machine.config) HashAlgorithm descendant.
</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public bool VerifyHash (byte[] rgbHash, string str, byte[] rgbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyHash(unsigned int8[] rgbHash, string str, unsigned int8[] rgbSignature) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rgbSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbHash">The hash to be verified.</param>
        <param name="str">OID for the hash algorithm using in the signature.</param>
        <param name="rgbSignature">An array of bytes containing the RSA signature of the specified hash.</param>
        <summary>Verify the signature using the specified hash value. </summary>
        <returns>True if the signature can be verified, false otherwise.</returns>
        <remarks>This method is LIMITED to SHA1 and MD5 like the MS framework 1.0 and 1.1 because there's no method to get a hash algorithm from an OID.  However there's no such limit when using the RSAPKCS1[De]Formatter class.
</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

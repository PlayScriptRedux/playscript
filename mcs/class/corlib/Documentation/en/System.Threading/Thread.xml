<Type Name="Thread" FullName="System.Threading.Thread" FullNameSP="System_Threading_Thread" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed Thread extends System.Object" />
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <para> Represents a sequential
      thread of execution. </para>
    </summary>
    <remarks>
      <para> A process can create
      and execute one or more threads to execute a portion of the program
      code associated with the process. A <see cref="T:System.Threading.ThreadStart" /> delegate is used to specify
      the program code
      executed by a thread.</para>
      <para>Some operating systems might
      not utilize the concepts of threads or preemptive scheduling. Also, the concept
      of "thread priority" might not exist at all or its meaning might vary, depending on
      the underlying operating system. Implementers of the <see cref="T:System.Threading.Thread" />
      
      type are required to describe their threading policies,
      including what thread priority means, how many threading priority
      levels exist, and
      whether scheduling is preemptive.</para>
      <para> For the duration of its existence, a thread is always in one
      or more of the states defined by <see cref="T:System.Threading.ThreadState" />. A scheduling priority level, as defined
      by <see cref="T:System.Threading.ThreadPriority" /> , can be requested for a thread, but it might
      not be honored
      by the operating system.</para>
      <para>If an unhandled exception is thrown in the code executed by a thread created
      by an application, a <see cref="F:System.AppDomain.UnhandledException" /> event is raised (<see cref="P:System.UnhandledExceptionEventArgs.IsTerminating" /> is set to <see langword="false" />), and the thread
      is terminated; the current process is not terminated.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Threading.ThreadStart start)" />
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegate that references the methods to be invoked when the new thread begins executing. </param>
        <summary>
          <para> Constructs and initializes a new instance of the <see cref="T:System.Threading.Thread" />
class.</para>
        </summary>
        <remarks>
          <para>
            <SPAN>
              <block subset="none" type="note">To schedule the thread for execution, call <see cref="M:System.Threading.Thread.Start" />.</block>
            </SPAN>
          </para>
          <para>
            <SPAN>Until <see cref="M:System.Threading.Thread.Start" /> is called, the thread's state includes <see cref="F:System.Threading.ThreadState.Unstarted" />.</SPAN>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start " />is <see langword="null" /> . </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <param name="maxStackSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <param name="maxStackSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Abort()" />
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on
   which it is invoked to begin the process of terminating the thread. In all but
   the most extraordinary situations, calling this method will terminate
   the thread.
   </para>
        </summary>
        <remarks>
          <para> When this method is invoked on a thread, the system
      throws a <see cref="T:System.Threading.ThreadAbortException" /> in the
      thread to abort it. Invoking <see cref="M:System.Threading.Thread.Abort(System.Object)" /> on a thread is similar
      to arranging for the target thread to throw a <see cref="T:System.Threading.ThreadAbortException" />. Because, unlike other
      exceptions, a <see cref="T:System.Threading.ThreadAbortException" /> is sent to another thread, the exception might
      be delayed. A <see cref="T:System.Threading.ThreadAbortException" /> is required to be delayed if and while the
      target thread is executing any of the following:
      </para>
          <list type="bullet">
            <item>
              <term>
         
         unmanaged code</term>
            </item>
            <item>
              <term>
         
         a catch handler</term>
            </item>
            <item>
              <term>
         
         a finally clause</term>
            </item>
            <item>
              <term>
         
         a filter clause</term>
            </item>
            <item>
              <term>
         
         a type initializer</term>
            </item>
          </list>
          <para>A thread abort proceeds as follows:</para>
          <list type="number">
            <item>
              <term>
                <para> An abort begins at the earliest of the following
         times:</para>
                <para> a. when the thread transitions from unmanaged to managed code execution; </para>
                <para> b. when the thread finishes the outermost currently executing catch handler; </para>
                <para> c. immediately if the thread is running managed code outside of any catch handler, finally clause, filter clause or type initializer </para>
              </term>
            </item>
            <item>
              <term>
                <para> Whenever an outermost catch handler finishes
            execution, the <see cref="T:System.Threading.ThreadAbortException" />
            is rethrown unless the thread being
            aborted has called <see cref="M:System.Threading.Thread.ResetAbort" /> since the call to <see cref="M:System.Threading.Thread.Abort(System.Object)" />.
            </para>
              </term>
            </item>
            <item>
              <term>
                <para> When all finally blocks have been called and the
               thread is about to transition to any unmanaged code which executed before the
               first entry to managed code, <see cref="M:System.Threading.Thread.ResetAbort" />
               is called so that a return to managed code will consider the abort to have been successfully processed.
               </para>
              </term>
            </item>
          </list>
          <para> Unexecuted <see langword="finally" /> blocks
      are executed before the thread is aborted; this includes any finally block that
      is executing when the exception is thrown. The thread is not guaranteed to abort
      immediately, or at all. This situation can occur if a thread does an unbounded
      amount of computation in the finally blocks that are called as part
      of the abort procedure, thereby indefinitely delaying the abort. To ensure a thread has aborted, invoke <see cref="M:System.Threading.Thread.Join" />
      on the thread after calling <see cref="M:System.Threading.Thread.Abort(System.Object)" /> . </para>
          <para> If <see cref="M:System.Threading.Thread.Abort(System.Object)" /> is called on a thread that has not been
   started, the thread aborts when <see cref="M:System.Threading.Thread.Start" /> is called. If the target thread is blocked or sleeping in managed code and is not inside any of the code blocks that are required to delay an abort, the thread is resumed and immediately aborted.</para>
          <para> After <see cref="M:System.Threading.Thread.Abort(System.Object)" />
is invoked on a thread, the state
of the thread includes <see cref="F:System.Threading.ThreadState.AbortRequested" />. After the thread has
terminated as a result of a successful call to <see cref="M:System.Threading.Thread.Abort(System.Object)" />, the state of the thread includes
<see cref="F:System.Threading.ThreadState.Stopped" /> and <see cref="F:System.Threading.ThreadState.Aborted" />
. </para>
          <para>
            <block subset="none" type="note">With sufficient permissions, a
   thread that is the target of a <see cref="M:System.Threading.Thread.Abort(System.Object)" /> can cancel the abort using
   the <see cref="M:System.Threading.Thread.ResetAbort" />
   method. For an example that demonstrates calling the <see cref="M:System.Threading.Thread.ResetAbort" /> method, see <see cref="T:System.Threading.ThreadAbortException" />
   .</block>
          </para>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>
            <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for the thread to be aborted.</SPAN>
          </SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the thread to be aborted. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Abort(object stateInfo)" />
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">A <see cref="T:System.Object" /> that contains application-specific information<SPAN>, such as state, </SPAN><SPAN>which can be used by the thread being aborted.</SPAN></param>
        <summary>
          <para> Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is
   invoked to begin the process of terminating the thread. In all but the most extraordinary situations, calling this method will terminate
   the thread.
   </para>
        </summary>
        <remarks>
          <para>The object passed as the <paramref name="stateInfo" />
parameter can be obtained by accessing the
<see cref="P:System.Threading.ThreadAbortException.ExceptionState" /> 
property.</para>
          <para>
            <block subset="none" type="note">For details on
   aborting threads, see <see cref="M:System.Threading.Thread.Abort(System.Object)" />
   ().</block>
          </para>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>
            <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for this thread.</SPAN>
          </SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the thread to be aborted. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The thread's current principal.</summary>
        <value>An object implementing <see cref="T:System.Security.Principal.IPrincipal" /> which encapsulates information about the principal which the thread is executing on behalf of.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="ILASM" Value=".property class System.Threading.Thread CurrentThread { public hidebysig static specialname class System.Threading.Thread get_CurrentThread() }" />
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>Gets a <see cref="T:System.Threading.Thread" />
instance that represents the currently executing thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> An instance of <see cref="T:System.Threading.Thread" /> representing the current thread.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Releases the resources held by this instance.
 </para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="note">Application code
 does not call this method; it is automatically invoked during garbage
 collection.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see CompressedStack class")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.AppDomain GetDomain()" />
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an object representing the application domain in
      which the current thread is executing.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.AppDomain" /> object that represents the current application domain.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="ILASM" Value=".property bool IsAlive { public hidebysig specialname instance bool get_IsAlive() }" />
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value
   indicating the execution status of the current thread.
   </para>
        </summary>
        <value>
          <para>
            <see langword="true " />
if this thread has been started, and has not terminated; otherwise,
<see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="ILASM" Value=".property bool IsBackground { public hidebysig specialname instance bool get_IsBackground() public hidebysig specialname instance void set_IsBackground(bool value) }" />
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets or sets a <see cref="T:System.Boolean" />
value indicating whether a thread is a background thread.</para>
        </summary>
        <value>
          <para>
            <see langword="true " />if the thread is or is to become
   a background thread; otherwise, <see langword="false" />.
   </para>
        </value>
        <remarks>
          <para>The default value of this property is <see langword="false" />. The property value can be changed before
   the thread is started and before it terminates.</para>
          <para>
            <block subset="none" type="note">A thread is either
   a background thread or a foreground thread. Background threads are identical to
   foreground threads except for the fact that background threads do not
   prevent a process from terminating. Once all foreground threads belonging to a
   process have terminated, the execution engine ends the process by invoking
<see cref="M:System.Threading.Thread.Abort(System.Object)" /> on any background threads that
   
   are
   still alive. </block>
          </para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"> The thread has reached the <see cref="F:System.Threading.ThreadState.Stopped" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Join()" />
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Blocks the calling thread until the thread on which this method
      is invoked terminates.
      </para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="note">Use this method to
      ensure a thread has terminated. The caller will block indefinitely if the thread
      does not
      terminate.</block>
          </para>
          <para>
            <see cref="M:System.Threading.Thread.Join" /> cannot be invoked on a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the calling thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />. </para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">A <see cref="T:System.Int32" /> containing the number of milliseconds to wait for the thread to terminate. </param>
        <summary>
          <para> Blocks the calling thread until the thread on which this method is invoked terminates or the specified time elapses.
      </para>
        </summary>
        <returns>
          <para>
            <see langword="true " />if the thread has terminated; <see langword="false " /> if the
   thread has not terminated after <paramref name="millisecondsTimeout" />
   has elapsed.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">If <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> is specified for <paramref name="millisecondsTimeout" />, this method
   behaves identically to <see langword="Join" />
   (), except for the return value.</block>
          </para>
          <para>
            <see langword="Join" /> cannot be invoked on a thread
that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the calling thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> .</exception>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds to wait indefinitely. </param>
        <summary>
          <para> Blocks the calling thread until the thread on which this method is invoked terminates or the specified time
      elapses.
      </para>
        </summary>
        <returns>
          <para>
            <see langword="true " />if the thread has terminated;
<see langword="false " /> if the thread has not terminated after the amount 
   of time specified by <paramref name="timeout" />
   has elapsed.</para>
        </returns>
        <remarks>
          <para>This method converts <paramref name="timeout " />to milliseconds,
   tests the validity of the converted value, and calls <see cref="M:System.Threading.Thread.Join" />(<see cref="T:System.Int32" />).</para>
          <para>
            <block subset="none" type="note">If <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds is specified for
<paramref name="timeout" />, this method 
behaves identically to <see langword="Join" /> (),
except for the return value.</block>
          </para>
          <para>
            <see langword="Join" /> cannot be invoked on a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</para>
          <para>This method changes the state of the current thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" qualify="true" /> milliseconds.</exception>
        <exception cref="T:System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state. </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Guarantees that all subsequent loads or stores from the current thread will not access memory until after all previous loads and stores from the current thread have completed, as observed from this or other threads.</para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="ILASM" Value=".property string Name { public hidebysig specialname instance string get_Name() public hidebysig specialname instance void set_Name(string value) }" />
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets or
      sets the name of
      the thread.
      </para>
        </summary>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   name of the thread, or <see langword="null" /> if no name
   was set.</para>
        </value>
        <remarks>
          <para>This property is write-once. Once this property has been 
      set to a non-null value, attempts to set this property to a new value cause an exception.</para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A set operation was requested, and the <see langword="Name" /> property has already been set.</exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Threading.ThreadPriority Priority { public hidebysig specialname instance valuetype System.Threading.ThreadPriority get_Priority() public hidebysig specialname instance void set_Priority(valuetype System.Threading.ThreadPriority value) }" />
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>
      Gets or sets a value indicating the scheduling priority of a thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> A <see cref="T:System.Threading.ThreadPriority" /> value.
   </para>
        </value>
        <remarks>
          <para>A thread can be assigned any one of the following
      priority values:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Highest" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.AboveNormal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Normal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.BelowNormal" />
              </term>
            </item>
            <item>
              <term>
                <see cref="F:System.Threading.ThreadPriority.Lowest" />
              </term>
            </item>
          </list>
          <para> The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</para>
          <para>Operating systems are not required to honor the priority
   of a thread.</para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"> The thread is in the <see cref="F:System.Threading.ThreadState.Stopped" /> state.</exception>
        <exception cref="T:System.ArgumentException">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value. </exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void ResetAbort()" />
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Cancels a <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</para>
        </summary>
        <remarks>
          <para> This method cannot be called by untrusted code.
      </para>
          <para> When a call is made to <see cref="M:System.Threading.Thread.Abort(System.Object)" />
to destroy a thread, the system throws a <see cref="T:System.Threading.ThreadAbortException" />. <see cref="T:System.Threading.ThreadAbortException" /> is a special
exception that can be caught by application code, but is rethrown at the end of
the catch block unless <see langword="ResetAbort " />is called.
<see langword="ResetAbort " />cancels the request to 
abort, and prevents the <see langword=" ThreadAbortException" />
from terminating the thread.</para>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <see cref="M:System.Threading.Thread.Abort(System.Object)" /> was not invoked on the current thread.</exception>
        <exception cref="T:System.Security.SecurityException">
          <SPAN>Caller does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> security permission for the current thread.</SPAN>
        </exception>
        <permission cref="!:System.Security.SecurityPermission">Requires permission to control the current thread. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <example>
          <para>For an example that demonstrates calling 
      this method, see <see cref="T:System.Threading.ThreadAbortException" /> .</para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see CompressedStack class")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">To be added.</param>
        <param name="data">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sleep(int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">A <see cref="T:System.Int32" /> containing the number of milliseconds for which the thread is blocked. Specify zero to indicate that this thread should be suspended temporarily to allow other waiting threads to execute. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> to block the thread indefinitely. </param>
        <summary>
          <para> Blocks the current thread for the specified number of milliseconds.
      </para>
        </summary>
        <remarks>
          <para>The thread will not be scheduled for execution by
      the operating system for the amount of time specified. This method changes the
      state of the thread to include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> .</exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sleep(valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> set to the amount of time for which the current thread will be blocked. Specify zero to indicate that this thread should be suspended temporarily to allow other waiting threads to execute. Specify <see cref="F:System.Threading.Timeout.Infinite" qualify="true" /> milliseconds to suspend the thread indefinitely. </param>
        <summary>
          <para> Blocks the current thread for a specified time.
      </para>
        </summary>
        <remarks>
          <para>This method converts <paramref name="timeout " />to milliseconds,
   tests the validity of the converted value, and calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)" />(<see cref="T:System.Int32" />).</para>
          <para>The thread will not be scheduled for execution by the operating system
   for the amount of time specified. This method changes the state of the thread to
   include <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" qualify="true" /> milliseconds.</exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Start()" />
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Causes the operating system to consider the thread ready 
      to be scheduled for execution.</para>
        </summary>
        <remarks>
          <para>Calling <see cref="M:System.Threading.Thread.Start" /> removes the <see cref="F:System.Threading.ThreadState.Unstarted" /> state from the
<see cref="P:System.Threading.Thread.ThreadState" /> of the thread.</para>
          <para> Once a thread is started,
   the operating system can schedule it for execution. When the thread begins executing, the <see cref="T:System.Threading.ThreadStart" />
   delegate supplied to the constructor for the thread invokes its
   methods.</para>
          <para> Once the thread terminates, it cannot be restarted with another call to <see cref="M:System.Threading.Thread.Start" />.</para>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory available to start the thread.</exception>
        <exception cref="T:System.NullReferenceException">This method was invoked on a <see langword="null" /> thread reference.</exception>
        <exception cref="T:System.Threading.ThreadStateException">The thread has already been started. </exception>
        <example>
          <para>The following example demonstrates creating a thread and starting it.</para>
          <code lang="C#">using System;
using System.Threading;
public class ThreadWork {
  public static void DoWork() {
    for (int i = 0; i&lt;3;i++) {
         Console.WriteLine ("Working thread ...");
         Thread.Sleep(100);
    }
  }
}
class ThreadTest{
  public static void Main() {
    ThreadStart myThreadDelegate = new ThreadStart(ThreadWork.DoWork);
    Thread myThread = new Thread(myThreadDelegate);
    myThread.Start();
    for (int i = 0; i&lt;3; i++) {
        Console.WriteLine("In main.");
        Thread.Sleep(100);
    }
  }
}
   </code>
          <para>One possible set of output is</para>
          <c>
            <para>In main. </para>
            <para>Working thread ... </para>
            <para>In main. </para>
            <para>Working thread ... </para>
            <para>In main. </para>
            <para>Working thread ... </para>
          </c>
          <para> Note that the sequence of the output statements is not guaranteed to be identical across systems. </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">To be added.</param>
        <param name="rgszNames">To be added.</param>
        <param name="cNames">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="rgDispId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="ppTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">To be added.</param>
        <param name="riid">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="wFlags">To be added.</param>
        <param name="pDispParams">To be added.</param>
        <param name="pVarResult">To be added.</param>
        <param name="pExcepInfo">To be added.</param>
        <param name="puArgErr">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Threading.ThreadState ThreadState { public hidebysig specialname instance valuetype System.Threading.ThreadState get_ThreadState() }" />
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
            <SPAN>Gets a value containing the
      states of the current thread.</SPAN>
          </para>
        </summary>
        <value>
          <para> A combination of one or more <see cref="T:System.Threading.ThreadState" /> values, which indicate
   the state of the current thread.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>A thread is running if the value returned by this property does not include <see cref="F:System.Threading.ThreadState.Unstarted" /> and does not include <see cref="F:System.Threading.ThreadState.Stopped" />.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static byte VolatileRead (class System.Byte&amp; address)" />
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Byte" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Byte" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float64 VolatileRead (class System.Double&amp; address)" />
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Double" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Double" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int16 VolatileRead (class System.Int16&amp; address)" />
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int16" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int16" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 VolatileRead (class System.Int32&amp; address)" />
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int32" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int64 VolatileRead (class System.Int64&amp; address)" />
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int64" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int64" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static intptr VolatileRead (class System.IntPtr&amp; address)" />
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.IntPtr" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.IntPtr" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static object VolatileRead (class System.Object&amp; address)" />
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Object" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static sbyte VolatileRead (class System.Sbyte&amp; address)" />
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.SByte" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.SByte" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float32 VolatileRead (class System.Single&amp; address)" />
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Single" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Single" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint16 VolatileRead (class System.UInt16&amp; address)" />
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt16" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt16" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint32 VolatileRead (class System.UInt32&amp; address)" />
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt32" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt32" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static uint64 VolatileRead (class System.UInt64&amp; address)" />
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64 address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt64" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UInt64" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UIntPtr" /> that specifies the address in memory from which to read.</param>
        <summary>
          <para>Performs a volatile read from the specified address.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.UIntPtr" /> containing the value at the specified address after any pending writes.</para>
        </returns>
        <remarks>
          <para>The value at the given address is atomically loaded with acquire semantics, meaning that the read is guaranteed to occur prior to any references to memory that occur after the execution of this method in the current thread. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileWrite" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the load CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Byte&amp; address, byte value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8 address, unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Byte" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Byte" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Double&amp; address, float64 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64 address, float64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Double" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Double" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int16&amp; address, int16 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16 address, int16 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int16" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int16" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int32&amp; address, int32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32 address, int32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int32" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int32" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Int64&amp; address, int64 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64 address, int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Int64" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Int64" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.IntPtr&amp; address, IntPtr value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int address, native int value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.IntPtr" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.IntPtr" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Object&amp; address, object value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object address, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Object" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Object" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.SByte&amp; address, sbyte value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8 address, int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.SByte" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.SByte" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.Single&amp; address, float32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32 address, float32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.Single" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.Single" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UInt16&amp; address, uint16 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16 address, unsigned int16 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt16" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt16" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UInt32&amp; address, uint32 value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32 address, unsigned int32 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt32" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt32" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64 address, unsigned int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UInt64" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UInt64" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void VolatileWrite (class System.UIntPtr&amp; address, UIntPtr value)" />
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int address, native unsigned int value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">A reference to a <see cref="T:System.UIntPtr" /> that specifies the address in memory at which to write.</param>
        <param name="value">A <see cref="T:System.UIntPtr" /> that specifies the value to write.</param>
        <summary>
          <para>Performs a volatile write to the specified address.</para>
        </summary>
        <remarks>
          <para>The value is written atomically to the specified address with release semantics, meaning that the write is guaranteed to happen after any references to memory that occur prior to the execution. It is recommended that <see cref="M:System.Threading.Thread.VolatileRead" /> and <see cref="M:System.Threading.Thread.VolatileWrite" /> be used in conjunction. Calling this method affects only this single access; other accesses to the same location are required to also be made using this method or <see cref="M:System.Threading.Thread.VolatileRead" /> if the volatile semantics are to be preserved. This method has exactly the same semantics as using the volatile prefix on the store CIL instruction, except that atomicity is provided for all types, not just those 32 bits or smaller in size. <block subset="none" type="note">For additional information, see Partition I of the CLI Specification.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>
